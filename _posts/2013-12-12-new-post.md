---
layout: post
title: "Ruby Meta Programming - book"
subtitle: 
cover_image: 
excerpt: ""
category: ""
tags: [ruby]
draft: false

---

# 1. Object Model

	Object.methods
	String.instance_methods
	Class.instance_methods(false) # non-inherited methods 
	
	superclass
	
> ? p49, `load`


### calling a method

1. look for the method

in the inheritance chain, look for the method

2. execute

#### `Kernel` module

	>> Kernel.private_instance_methods.grep(/^pr/)
	=> [:printf, :print, :proc]

#### `private` method

This is the only way to call `private` method. 

{% highlight ruby linenos %}
class A
  def public_method
    private_method
    
  end

  private
  def private_method
    p "private"
  end
end

A.new.public_method
{% endhighlight %}

__Add `self.` to line 3, it will fail__

object can call private methods of superclass

Use `ancestors` method to track.

{% highlight ruby %}
module Printable
  def print
    p 'Printable#print'
  end

  def prepare_cover
    p 'Printable#prepare_cover'
  end
end

module Document
  def print_to_screen
    prepare_cover
    format_for_screen
    print
  end

  def format_for_screen
    p 'Document#format_for_screen'
  end

  def print
    p 'Document#print'
  end
end

class Book
  include Document
  include Printable
end

b = Book.new
b.print_to_screen

p Book.ancestors
{% endhighlight %}

output: 

	"Printable#prepare_cover"
	"Document#format_for_screen"
	"Printable#print"
	[Book, Printable, Document, Object, Kernel, BasicObject]

The reason to print `Printable#print` is that, `print` is send to `self` implicitly. From the ancestor chain, we can see `Book` -> `Printable`, and we found `print`.

# 2. Methods

_static language_ and _dynamic language_

#### Dynamic dispatch (Dynamic calling)

`.` to call a method, is actually calling `send` method. `obj.send(:my_method, 3)`

Example for `Test::Unit`, calling every test case method, which starts with `test`

{% highlight ruby %}
method_names = public_instance_methods(true)
tests = method_names.delete_if {|method_name| methdo_name !~ /^test./}
{% endhighlight %}

#### Dynamic define

`Module#define_method()` can define a method

{% highlight ruby %}
class MyClass
  define_method :my_method do |my_arg|
    my_arg * 3
  end
end

obj = MyClass.new
obj.my_method(2) # => 6
{% endhighlight %}

`.methods.grep(regex)`

### `method_missing`

override `method_missing` can call some methods which do not exist.

{% highlight ruby %}

class Table                                                                                                                                                                        
  def method_missing(id, *args, &block)                                                                                                                                            
    return as($1.to_sym, *args, &block) if id.to_s =~ /^to_(.*)/                                                                                                                   
    return rows_with($1.to_sym => args[0]) if id.to_s =~ /^rows_with_(.*)/                                                                                                         
    super                                                                                                                                                                          
  end                                                                                                                                                                              
end  

# rows_with_country is valid
# to_csv is valid
{% endhighlight %}

#### example: dynamic getter and setter for undefined attributes

{% highlight ruby %}
class MyOpenStruct                                                                                                                                                                 
  def method_missing(id, *args, &block)                                                                                                                                            
    attribute = name.to_s                                                                                                                                                          
    if attribute =~ /=$/                                                                                                                                                           
      @attributes[attribute.chop] = args[0]                                                                                                                                        
    else                                                                                                                                                                           
      @attributes[attribute]                                                                                                                                                       
    end                                                                                                                                                                            
  end                                                                                                                                                                              
end 
{% endhighlight %}

### Dynamic Proxy

#### `DelegateClass`

Delegate Class creates a new class from old one, and creates a `method_missing` in it, and redirect the call of its `method_missing` to the delegated class

{% highlight ruby %}
class Assistant
# ...
end

class Manager < DelegateClass(Assistant)
end
{% endhighlight %}

### Refactored `Computer` 

{% highlight ruby %}
class Computer                                                                                                                                                                     
  def method_missing(name, *args, &block)                                                                                                                                          
    super if !@data_source.respond_to?("get_#{name}_info")                                                                                                                         
    info = @data_source.send("get_#{name}_info", argss[0])                                                                                                                         
    price = @data_source.send("get_#{name}_price", args[0])                                                                                                                        
    result = "#{name.to_s.capitalize}: #{info} ($#{price})"                                                                                                                        
    return " * #{result}" if price >= 100                                                                                                                                          
    result                                                                                                                                                                         
  end                                                                                                                                                                              
end 
{% endhighlight %}

if `get_#{name}_info` is not defined, then send to `super` and raise error.

else generate `info` and `price` and output `result`

### override `respond_to?`

It sometimes lies. If a method defined in `method_missing`, then `respond_to?` will return wrong answer, which is a `false`

{% highlight ruby %}
def respond_to?
	@data_source.respond_to? "get_#{method}_info") || super
end
{% endhighlight %}

#### `const_missing`

Called when constant is missing.

### Undefined variable in `method_missing` will call `method_missing` again. Recurrisve loop

### Blank Slate

best practise: remove the inherited ghost method, to avoid name conflict. Because 

To remove method, use `Module#undef_method` (removes all the methods), or `Module#remoev_method` (remove receiver's method, keep inherited methods)

{% highlight ruby %}
class Computer
  instance_merhods.each do |m|
	undef_method m unless m.to_s =~ /^__|method_missing|respond_to?/
  end
	
  # ...
end
{% endhighlight %}

Do not remove methods start with `__`, and leave some other methods.

# 3. Blocks

{% highlight ruby %}
def a_method(a,b)
  a + yield(a,b)
end

a_method(1,2) { |x,y| (x+y)*3 }
{% endhighlight %}

`Kernel#block_given?()` to check whether current method has a block to `yield`

### closure

Block is a complete program, can be executed immediately.

`Kernel#local_variables` can track local variables

### scope

`Class.new` is an alternative to `class`

#### Flattening the scope

{% highlight ruby %}
my_var = "var"
MyClass = Class.new do
  puts "#{my_var} in class"
  def my_method
    puts "#{my_var} in method"
  end
end

MyClass.new.my_method
  
{% endhighlight %}

#### adding shared variable to methods

{% highlight ruby %}
def define_methods
  shared = 0
  
  Kernel.send :define_method, :counter do
    shared
  end
  Kernel.send :define_method, :inc do |x|
    shared += x
  end
end 

define_methods

counter
inc(4)
counter
{% endhighlight %}

`Kernel#counter` and `Kernel#inc` are sharing `shared` now

#### to transpass scope gate, use method call instead of `class`, `module` and `def` keywords

### `instance_eval`

Things passed into `instance_eval` is __context probe__.

`instance_exec` allow parameters

{% highlight ruby %}
class C
  def initialize
    @x, @y = 1, 2
  end
end

C.new.instance_exec(3) {|arg| (@x + @y) * arg }
{% endhighlight %}

### Callable object

#### `Proc` object

Proc: convert block to object

* `Proc.new`
* `Proc::lambda` (Kernel method)
* `proc` (Kernel method)

`dec = lambda { |x| x - 1 }`


#### `&` operator

When using `yield`

1. you want to pass the block to another method
2. you want to convert the block to a Proc

Then you need to mark this block variable using `&`

{% highlight ruby %}
def my_method(&the_proc)
  the_proc
end

p = my_method { |name| "Hello, #{name}" }
puts p.call("world")
{% endhighlight %}

Use `&` to convert `Proc` to block.

{% highlight ruby %}
def my_method(greeting)
  puts "#{greeting} #{yield}"
end

my_proc = proc { "world" }
my_method("Hello", &my_proc)
{% endhighlight %}

`my_proc` can be yield.

#### `lambda` and `proc` difference

##### 1. The meaning of `return` is different.

* `lambda` returns value from the proc
* `proc` returns(procedurely) from the code block

{% highlight ruby %}
def double
  p = Proc.new { return 10 }
  return 20 # unreachable code
end
{% endhighlight %}

Correct way

{% highlight ruby %}
def double
  p = Proc.new { 10 }
  return 20 # unreachable code
end
{% endhighlight %}

##### 2. number of arguments

if a `proc` has 2 arguments

* if defined using `lambda`, it only accept 2 arguments. No more, no less, otherwise program will fail
* if defined using `proc` or `Proc`, it will ignore redundant arguments, the non-passed arguments are defined as `nil`

##### Best practise

If you can use `lambda`, then use `lambda`

#### `Kernel#proc`

* In Ruby 1.8, it is alias of `Kernel#lambda`
* In Ruby 1.9, it is alias of `Proc.new`

#### Method is also callable object, like `lambda`

Method can be detached and re-attached.

{% highlight ruby %}
unbound = m.unbound # m is a method object
another_obj = MyClass.new
m = unbound.bind(another_obj)
m.call

{% endhighlight %}

Method can be binded to an object and run. But `lambda` is a closure. It does not require to be binded.

### Create a DSL

{% highlight ruby %}
def event(name, &block)                                                                                                                                                                                                                       
  @events[name] = block                                                                                                                                                                                                                       
end                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                              
def setup(&block)                                                                                                                                                                                                                             
  @setups << block                                                                                                                                                                                                                            
end                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                              
Dir.glob('*events.rb').each do |file|                                                                                                                                                                                                         
  @setups = []                                                                                                                                                                                                                                
  @events = []                                                                                                                                                                    
  load file                                                                                                                                                                       
  @events.each_pair do |name, event|                                                                                                                                              
    env = Object.new                                                                                                                                                              
    @setups.each do |setup|                                                                                                                                                       
      env.instance_eval &setup                                                                                                                                                    
    end                                                                                                                                                                           
    p "ALERT: #{name}" if env.instance_eval &event                                                                                                                                
  end                                                                                                                                                                             
end   
{% endhighlight %}

The DSL file ends with `*events.rb`:

{% highlight ruby %}
event 'the sky is falling' do
  @sky_height < 300
end

event "It's getting closer" do
  @sky_height = 100
end

setup do
  @sky_height = 100
end

setup do
  @mountains_height = 200
end
  
{% endhighlight %}

Refactor: eliminate global variables `@events` and `@setups`

{% highlight ruby %}
lambda {                                                                                                                                                                                                                                      
  setups = []                                                                                                                                                                                                                                 
  events = []                                                                                                                                                                     
                                                                                                                                                                                  
  Kernel.send :define_method, :event do |name, &block|                                                                                                                            
    events[name] = block                                                                                                                                                          
  end                                                                                                                                                                             
                                                                                                                                                                                  
  Kernel.send :define_method, :setup do |&block|                                                                                                                                  
    setups << block                                                                                                                                                               
  end                                                                                                                                                                             
                                                                                                                                                                                  
  Kernel.send :define_method, :each_event do |&block|                                                                                                                             
    events.each_pair do |name, event|                                                                                                                                             
      block.call name, event                                                                                                                                                      
    end                                                                                                                                                                           
  end                                                                                                                                                                             
                                                                                                                                                                                  
  Kernel.send :define_method, :each_setup do |&block|                                                                                                                             
    setups.each do |setup|                                                                                                                                                        
      block.call setup                                                                                                                                                            
    end                                                                                                                                                                           
}.call                                                                                                                                                                                                                                        
                                                                                                                                                                                  
Dir.glob('*events.rb').each do |file|                                                                                                                                                                                                                                                                                                                               
  @setups = []                                                                                                                                                                                                                                                                                                                                                      
  @events = []                                                                                                                                                                    
  load file                                                                                                                                                                       
  @events.each_pair do |name, event|                                                                                                                                              
    env = Object.new                                                                                                                                                              
    @setups.each do |setup|                                                                                                                                                       
      env.instance_eval &setup                                                                                                                                                    
    end                                                                                                                                                                           
    p "ALERT: #{name}" if env.instance_eval &event                                                                                                                                
  end                                                                                                                                                                             
end             
{% endhighlight %}

The starting `lambda` defines all the DSL methods. THe point is, the DSL methods are sharing local variables `events` and `setups`.

# 4 Class definitions

### `class_eval`

Run a block within current class

{% highlight ruby %}
def add_method_to(a_class)
  a_class.class_eval do
    def m; 'Hello!'; end
  end
end

add_method_to String
'abc'.m # => "Hello"
{% endhighlight %}

* `instance_eval` modifies `self`
* `class_eval` modifies current class and `self`

When defining class, `self` means current `Class` object
You can use variable outside of scope

### Singleton methods

Method effective on single object.

{% highlight ruby %}
str = ""

def str.title?
  self.upcase == self
end

str.title?
str.singleton_methods
{% endhighlight %}

Static method in Ruby defined as `def self.method`. This is actually a singleton method of the `Class` object.

Another way to define singleton method (class method)

{% highlight ruby %}
def Myclass.my_class_method; end
{% endhighlight %}

### Class macro

An example: `attr_accessor`, `attr_reader`. These are class macros.

All the `attr_*` are defined in `Module` class.

Write your own class macro

{% highlight ruby %}
class Book
  def self.deprecate(old_method, new_method)
    warn "Warning: #{old_method}() is deprecated. Use #{new_method}()"
    send(new_method, *args, &block)
  end
  
  # ...
end

deprecate :GetTitle, :title
{% endhighlight %}

### Eigenclass

A hidden class on the ancestors chain.

> insert a image here

To access eigenclass:

{% highlight ruby %}
obj = Object.new
eigenclass = class << obj
  # ...
end
{% endhighlight %}

Eigenclass is a singleton class object. It stores the singleton method of an object.

An helper method to get eigenclass object:

{% highlight ruby %}
class Object 
  def eigenclass
    class << self; self; end
  end
end
{% endhighlight %}

To define method in eigen class:

{% highlight ruby %}
class MyClass
  class << self
    def my_method; end
  end
ed
{% endhighlight %}

# 5. Code that writes code

### `Kernel#eval`

It uses string to eval:

{% highlight ruby %}
array  = [10, 20]
element = 30
eval "array << element" # => [10, 20, 30]
{% endhighlight %}

#### Example from Capistrano

{% highlight ruby %}
map = {} # a hash

map.each do |old, new|
  # ...
  eval " task #{old.inspect} do
    warn \"[DEPRECATED] `#{old}' is deprecated. Use `#{new}' instead.\"
    find_and execute_task #{new.inspect}
  end"
end
{% endhighlight %}

### `Binding` class

`Binding` represents a variable scope.

{% highlight ruby %}
class MyClass
  def my_method
    @x = 1
    binding
  end 
end

b = MyClass.new.my_method
{% endhighlight %}

For `*eval()` methods, you can pass a `Binding` object as parameter. Then code of `eval` will execute in scope.

	eval "@x", b # => 1
	
A pre-defined constant `TOPLEVEL_BINDING`

### `here` document

For define multiple lines of code

{% highlight ruby %}
s = <<END
  # some code ...
END

p s
{% endhighlight %}

### security

To prevent `eval` problem, use dynamic dispatch to replace `eval`

{% highlight ruby %}
def explore_array(method, *args)
  ['a', 'b', 'c'].send(method, *args)
end

def explore_array_eval(method)
  code = "['a', 'b', 'c'].#{method}"
  eval code
end
{% endhighlight %}

### Tainted object

{% highlight ruby %}
user_input = "User input: #{gets()}"
puts user_input.tainted?

> x=1
> => true

{% endhighlight %}

#### Security level

0 -> 4. 0 means can do anything. >0, cannot execute tainted code